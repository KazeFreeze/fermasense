# Project Extract (+checked)

# Structure
> fermasense_dashboard
  > data
    - equalization_log.csv
    - fermentation_log.csv
  > static
    > css
      - style.css
    > img
    > js
      - main.js
  > templates
    - index.html
  - app.py

# Contents

@ app.py
from flask import Flask, render_template, request, jsonify, send_file
from flask_socketio import SocketIO, emit
import serial
import threading
import time
import csv
import os
from datetime import datetime

# --- Configuration ---
SERIAL_PORT = None # Will attempt to auto-detect, or set manually e.g., 'COM3' or '/dev/ttyUSB0'
BAUD_RATE = 115200
DATA_DIR = 'data'
MAIN_LOG_FILE = os.path.join(DATA_DIR, 'fermentation_log.csv')
EQ_LOG_FILE = os.path.join(DATA_DIR, 'equalization_log.csv')

# --- Flask App Setup ---
app = Flask(__name__)
app.config['SECRET_KEY'] = 'fermasense_secret_!@#' # CHANGE THIS FOR PRODUCTION
socketio = SocketIO(app, async_mode='threading')
ser = None # Global serial object

# --- Helper Functions ---
def ensure_dir_exists(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)

def find_serial_port():
    global SERIAL_PORT
    if SERIAL_PORT: # If manually set, try it first
        try:
            s_test = serial.Serial(SERIAL_PORT)
            s_test.close()
            print(f"Using manually set serial port: {SERIAL_PORT}")
            return SERIAL_PORT
        except serial.SerialException:
            print(f"Manually set port {SERIAL_PORT} not available. Attempting auto-detect.")

    if os.name == 'nt': # Windows
        ports = [f'COM{i}' for i in range(1, 257)]
    elif os.name == 'posix': # Linux/macOS
        ports = [f'/dev/ttyUSB{i}' for i in range(10)] + \
                [f'/dev/ttyACM{i}' for i in range(10)] + \
                [f'/dev/cu.usbserial-{i}' for i in range(10)] + \
                [f'/dev/cu.usbmodem{i}' for i in range(10)]
    else:
        return None

    for port_name in ports:
        try:
            s_test = serial.Serial(port_name)
            s_test.close()
            print(f"Auto-detected serial port: {port_name}")
            SERIAL_PORT = port_name
            return port_name
        except (OSError, serial.SerialException):
            continue
    print("No serial port detected automatically.")
    return None

def log_to_csv(file_path, data_dict, fieldnames):
    ensure_dir_exists(DATA_DIR)
    file_exists = os.path.isfile(file_path)
    try:
        with open(file_path, 'a', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            if not file_exists:
                writer.writeheader()
            writer.writerow(data_dict)
    except IOError as e:
        print(f"Error writing to CSV {file_path}: {e}")
        socketio.emit('mcu_log', {'type': 'error', 'message': f"CSV Write Error: {e}"})


# --- Serial Communication Thread ---
def serial_reader_thread():
    global ser
    print("Serial reader thread started.")
    while True:
        if not SERIAL_PORT:
            print("Serial port not configured. Retrying detection in 10s.")
            socketio.emit('mcu_log', {'type': 'error', 'message': 'Serial port not configured. Retrying detection...'})
            time.sleep(10)
            find_serial_port() # Attempt to find port again
            continue

        if ser is None or not ser.is_open:
            try:
                print(f"Attempting to connect to serial port: {SERIAL_PORT}")
                ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
                print(f"Successfully connected to {SERIAL_PORT}.")
                socketio.emit('mcu_log', {'type': 'info', 'message': f'Connected to FermaSense device on {SERIAL_PORT}'})
                send_command_to_mcu("GET_STATUS") # Get initial status
            except serial.SerialException as e:
                ser = None
                print(f"Serial connection error on {SERIAL_PORT}: {e}")
                socketio.emit('mcu_log', {'type': 'error', 'message': f'Serial connection failed: {e}. Retrying...'})
                time.sleep(5) # Wait before retrying
                find_serial_port() # Maybe the port changed
                continue
        try:
            if ser and ser.in_waiting > 0:
                line = ser.readline().decode('utf-8', errors='ignore').strip()
                if line:
                    # print(f"MCU Raw: {line}") # For debugging
                    timestamp_iso = datetime.now().isoformat()
                    parts = line.split(',')

                    if parts[0] == "DATA" and len(parts) == 6:
                        # Format: DATA,Timestamp_s,CurrentTemp,SetTemp,State,Mode
                        try:
                            payload = {
                                'server_time_iso': timestamp_iso,
                                'mcu_time_s': float(parts[1]),
                                'current_temp': float(parts[2]),
                                'set_temp': float(parts[3]),
                                'state': parts[4],
                                'mode': parts[5]
                            }
                            socketio.emit('new_data', payload)
                            log_to_csv(MAIN_LOG_FILE, payload,
                                       ['server_time_iso', 'mcu_time_s', 'current_temp', 'set_temp', 'state', 'mode'])
                        except ValueError as e:
                            print(f"Error parsing DATA line: {line} - {e}")
                            socketio.emit('mcu_log', {'type': 'error', 'message': f'Data parse error: {line}'})

                    elif parts[0] == "EQUALIZED" and len(parts) == 3:
                        # Format: EQUALIZED,TargetTemp,Duration_s
                        try:
                            eq_payload = {
                                'server_time_iso': timestamp_iso,
                                'target_temp': float(parts[1]),
                                'duration_s': float(parts[2])
                            }
                            socketio.emit('equalization_update', eq_payload)
                            log_to_csv(EQ_LOG_FILE, eq_payload, ['server_time_iso', 'target_temp', 'duration_s'])
                            socketio.emit('mcu_log', {'type': 'info', 'message': f"Equalized to {parts[1]}Â°C in {parts[2]}s"})
                        except ValueError as e:
                            print(f"Error parsing EQUALIZED line: {line} - {e}")
                            socketio.emit('mcu_log', {'type': 'error', 'message': f'Equalization parse error: {line}'})

                    elif parts[0] in ["INFO", "ERROR", "CMD_RECV", "STATUS"]:
                        log_type = 'info' if parts[0] != "ERROR" else 'error'
                        message = line # Send the whole line
                        if parts[0] == "STATUS" and len(parts) >= 8: # Update UI with initial status
                             # STATUS,mcu_time,currT,setT,State,Mode,Freq,isEq,eqTimestamp
                             try:
                                status_payload = {
                                    'mcu_time_s': float(parts[1]),
                                    'current_temp': float(parts[2]),
                                    'set_temp': float(parts[3]),
                                    'state': parts[4],
                                    'mode': parts[5],
                                    'frequency_ms': int(parts[6]),
                                    'is_equalizing': parts[7] == "TIMING_EQ",
                                    'setpoint_change_time_s': float(parts[8])
                                }
                                socketio.emit('initial_status', status_payload)
                                message = f"Initial Status Received: Temp {parts[2]}C, Set {parts[3]}C, Mode {parts[5]}"
                             except Exception as e:
                                message = f"Error parsing STATUS: {e}"
                                log_type = 'error'

                        socketio.emit('mcu_log', {'type': log_type, 'message': message})
                    else:
                        socketio.emit('mcu_log', {'type': 'unknown', 'message': f"MCU_UNKNOWN: {line}"})

        except serial.SerialException as e:
            print(f"Serial communication error: {e}")
            socketio.emit('mcu_log', {'type': 'error', 'message': f'Serial Port Error: {e}. Connection lost.'})
            if ser:
                ser.close()
            ser = None # Trigger reconnection attempt
            time.sleep(5)
        except Exception as e:
            print(f"Unexpected error in serial_reader_thread: {e}")
            socketio.emit('mcu_log', {'type': 'error', 'message': f'Backend error: {e}'})
            time.sleep(1) # Prevent rapid error loops

# --- Flask Routes ---
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/send_command_to_mcu', methods=['POST'])
def send_command_route():
    command_str = request.form.get('command')
    if not command_str:
        return jsonify({'status': 'error', 'message': 'No command provided.'}), 400

    if send_command_to_mcu(command_str):
        return jsonify({'status': 'success', 'message': f'Command "{command_str}" sent.'})
    else:
        return jsonify({'status': 'error', 'message': 'Failed to send command. MCU not connected or error.'}), 500

def send_command_to_mcu(command_string):
    global ser
    if ser and ser.is_open:
        try:
            ser.write((command_string + '\n').encode('utf-8'))
            print(f"Sent to MCU: {command_string}")
            socketio.emit('mcu_log', {'type': 'cmd_sent', 'message': f'CMD > {command_string}'})
            return True
        except Exception as e:
            print(f"Error writing to serial port: {e}")
            socketio.emit('mcu_log', {'type': 'error', 'message': f'Error sending command: {e}'})
            return False
    else:
        print("Serial port not available or not open.")
        socketio.emit('mcu_log', {'type': 'error', 'message': 'Cannot send command: Serial port unavailable.'})
        return False

@app.route('/get_historical_data', methods=['GET'])
def get_historical_data_route():
    try:
        ensure_dir_exists(DATA_DIR)
        data_points = []
        if os.path.exists(MAIN_LOG_FILE):
            with open(MAIN_LOG_FILE, 'r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    try:
                        # Convert to structure Chart.js expects {x: timestamp, y: value}
                        # server_time_iso,mcu_time_s,current_temp,set_temp,state,mode
                        dt_obj = datetime.fromisoformat(row['server_time_iso'])
                        data_points.append({
                            'x': dt_obj.timestamp() * 1000, # Chart.js wants ms
                            'current_temp': float(row['current_temp']),
                            'set_temp': float(row['set_temp'])
                        })
                    except (ValueError, KeyError) as e:
                        print(f"Skipping malformed row in CSV: {row} - {e}")
        return jsonify(data_points)
    except Exception as e:
        print(f"Error reading historical data: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/download_log/<log_type>')
def download_log_route(log_type):
    ensure_dir_exists(DATA_DIR)
    file_path = ""
    download_name = ""
    if log_type == 'main':
        file_path = MAIN_LOG_FILE
        download_name = 'fermasense_main_log.csv'
    elif log_type == 'equalization':
        file_path = EQ_LOG_FILE
        download_name = 'fermasense_equalization_log.csv'
    else:
        return "Invalid log type", 404

    if os.path.exists(file_path):
        return send_file(file_path, as_attachment=True, download_name=download_name, mimetype='text/csv')
    else:
        return f"{log_type.capitalize()} log file not found.", 404

# --- SocketIO Events ---
@socketio.on('connect')
def on_connect():
    client_sid = request.sid
    print(f'Client connected: {client_sid}')
    emit('mcu_log', {'type': 'info', 'message': 'Web client connected. Initializing...'})
    # Request current status from MCU when a new client connects
    send_command_to_mcu("GET_STATUS")

@socketio.on('disconnect')
def on_disconnect():
    client_sid = request.sid
    print(f'Client disconnected: {client_sid}')

if __name__ == '__main__':
    ensure_dir_exists(DATA_DIR)
    find_serial_port() # Initial attempt to find port

    # Start the serial reading thread as a daemon
    serial_thread = threading.Thread(target=serial_reader_thread, daemon=True)
    serial_thread.start()

    print(f"Starting FermaSense Web Dashboard on http://localhost:5000")
    socketio.run(app, host='0.0.0.0', port=5000, debug=False, allow_unsafe_werkzeug=True)

@ data\equalization_log.csv


@ data\fermentation_log.csv


@ templates\index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FermaSense: Smart Fermentation Monitor</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='css/style.css') }}"
    />
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.min.js"></script>
  </head>
  <body>
    <div class="dashboard-container">
      <header class="dashboard-header">
        <h1>FermaSense</h1>
        <p>Smart Fermentation Monitor and Control System</p>
      </header>

      <main class="dashboard-main">
        <section class="panel status-panel">
          <h2><span class="icon">ð</span>Current Status</h2>
          <div class="status-grid">
            <div>MCU Time: <strong id="mcuTime">--:--:--</strong> s</div>
            <div>Temperature: <strong id="currentTemp">--.- Â°C</strong></div>
            <div>Set Temp: <strong id="setTemp">--.- Â°C</strong></div>
            <div>Mode: <strong id="currentMode">-----</strong></div>
            <div class="state-display">
              State: <strong id="currentState">-----</strong>
              <span id="stateAnimation" class="animation-icon"></span>
            </div>
            <div>Read Interval: <strong id="readInterval">---- ms</strong></div>
          </div>
          <div class="equalization-info">
            Last Equalization: <span id="lastEqTime">N/A</span>
          </div>
        </section>

        <section class="panel control-panel">
          <h2><span class="icon">âï¸</span>System Controls</h2>
          <div class="control-group">
            <label for="targetTempInput">Target Temperature (Â°C):</label>
            <input
              type="number"
              id="targetTempInput"
              step="0.1"
              value="25.0"
              min="4"
              max="50"
            />
            <button onclick="setTargetTemperature()">Set Temp</button>
          </div>
          <div class="control-group">
            <label for="readIntervalInput">Read Interval (ms):</label>
            <input
              type="number"
              id="readIntervalInput"
              step="1000"
              value="5000"
              min="1000"
              max="600000"
            />
            <button onclick="setReadInterval()">Set Interval</button>
          </div>
          <div class="control-group mode-buttons">
            <button onclick="sendCommandToMCU('MODE_AUTO')" id="btnModeAuto">
              Auto Mode
            </button>
            <button
              onclick="sendCommandToMCU('MODE_MANUAL')"
              id="btnModeManual"
            >
              Manual Mode
            </button>
          </div>
          <div
            class="control-group manual-op-buttons"
            id="manualControls"
            style="display: none"
          >
            <span>Manual Operation:</span>
            <button onclick="sendCommandToMCU('MANUAL_HEAT')">Heat ð¥</button>
            <button onclick="sendCommandToMCU('MANUAL_IDLE')">Idle ð¤</button>
            <button onclick="sendCommandToMCU('MANUAL_COOL')">Cool âï¸</button>
          </div>
        </section>

        <section class="panel chart-panel">
          <h2><span class="icon">ð</span>Temperature Trend</h2>
          <div class="chart-controls">
            Time Range:
            <select id="chartTimeRange" onchange="updateChartDisplayRange()">
              <option value="live_1h" selected>Live (1 Hour)</option>
              <option value="live_6h">Live (6 Hours)</option>
              <option value="day">Today</option>
              <option value="3days">Last 3 Days</option>
              <option value="week">Last 7 Days</option>
              <option value="all">All Data</option>
            </select>
            <button onclick="loadHistoricalData()">Refresh Chart Data</button>
          </div>
          <div class="chart-wrapper">
            <canvas id="temperatureChart"></canvas>
          </div>
        </section>

        <section class="panel log-panel">
          <h2><span class="icon">ð</span>Device Logs & Messages</h2>
          <div id="mcuLogOutput" class="log-output"></div>
        </section>

        <section class="panel export-panel">
          <h2><span class="icon">ð¾</span>Data Export</h2>
          <button onclick="downloadLog('main')">Download Main Log (CSV)</button>
          <button onclick="downloadLog('equalization')">
            Download Equalization Log (CSV)
          </button>
        </section>
      </main>

      <footer class="dashboard-footer">
        <p>
          &copy; <span id="currentYear"></span> FermaSense Project. All rights
          reserved.
        </p>
      </footer>
    </div>

    <script src="{{ url_for('static', filename='js/main.js') }}"></script>
  </body>
</html>

@ static\css\style.css
/* static/css/style.css */
:root {
  --primary-color: #3498db; /* Bright Blue */
  --secondary-color: #2c3e50; /* Dark Blue-Gray */
  --accent-color: #e67e22; /* Orange for heating */
  --cool-color: #1abc9c; /* Turquoise for cooling */
  --idle-color: #95a5a6; /* Gray for idle */
  --bg-color: #ecf0f1; /* Light Gray Background */
  --panel-bg-color: #ffffff;
  --text-color: #333333;
  --light-text-color: #f8f9fa;
  --border-color: #bdc3c7;
  --success-color: #2ecc71;
  --error-color: #e74c3c;
  --font-family: "Roboto", "Segoe UI", sans-serif;
}

body {
  font-family: var(--font-family);
  margin: 0;
  background-color: var(--bg-color);
  color: var(--text-color);
  line-height: 1.6;
  font-size: 16px;
}

.dashboard-container {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.dashboard-header {
  background-color: var(--secondary-color);
  color: var(--light-text-color);
  padding: 20px 30px;
  text-align: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.dashboard-header h1 {
  margin: 0;
  font-size: 2.2em;
  font-weight: 500;
}

.dashboard-header p {
  margin: 5px 0 0;
  font-size: 1em;
  opacity: 0.9;
}

.dashboard-main {
  flex-grow: 1;
  padding: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 20px;
}

.panel {
  background-color: var(--panel-bg-color);
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.03);
  border: 1px solid var(--border-color);
}

.panel h2 {
  color: var(--secondary-color);
  margin-top: 0;
  font-size: 1.4em;
  padding-bottom: 10px;
  border-bottom: 1px solid var(--bg-color);
  display: flex;
  align-items: center;
}
.panel h2 .icon {
  margin-right: 10px;
  font-size: 1.2em;
}

/* Status Panel */
.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 10px;
  font-size: 0.95em;
}
.status-grid div {
  padding: 5px 0;
}
.status-grid strong {
  color: var(--primary-color);
  font-weight: 500;
}
.state-display strong {
  margin-right: 8px;
}
.animation-icon {
  display: inline-block;
  font-size: 1.2em;
  padding: 2px 6px;
  border-radius: 4px;
  color: white;
  min-width: 25px;
  text-align: center;
}
.state-heating .animation-icon {
  background-color: var(--accent-color);
  animation: pulse 1s infinite;
}
.state-cooling .animation-icon {
  background-color: var(--cool-color);
  animation: pulse 1s infinite;
}
.state-idle .animation-icon {
  background-color: var(--idle-color);
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.15);
  }
  100% {
    transform: scale(1);
  }
}
.equalization-info {
  margin-top: 15px;
  font-size: 0.9em;
  color: var(--text-color);
}
.equalization-info span {
  font-weight: 500;
  color: var(--primary-color);
}

/* Control Panel */
.control-group {
  margin-bottom: 15px;
}
.control-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 500;
  font-size: 0.9em;
}
.control-group input[type="number"] {
  padding: 8px 10px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  margin-right: 10px;
  width: 120px; /* Adjust as needed */
}
.control-group button,
.export-panel button {
  padding: 8px 15px;
  background-color: var(--primary-color);
  color: var(--light-text-color);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  font-size: 0.9em;
}
.control-group button:hover,
.export-panel button:hover {
  background-color: #2980b9; /* Darker primary */
}
.mode-buttons button.active {
  background-color: var(--secondary-color);
  font-weight: bold;
}
.manual-op-buttons button {
  margin: 5px;
}
.manual-op-buttons button:nth-child(1) {
  background-color: var(--accent-color);
} /* Heat */
.manual-op-buttons button:nth-child(1):hover {
  background-color: #d35400;
}
.manual-op-buttons button:nth-child(2) {
  background-color: var(--idle-color);
} /* Idle */
.manual-op-buttons button:nth-child(2):hover {
  background-color: #7f8c8d;
}
.manual-op-buttons button:nth-child(3) {
  background-color: var(--cool-color);
} /* Cool */
.manual-op-buttons button:nth-child(3):hover {
  background-color: #16a085;
}

/* Chart Panel */
.chart-panel {
  grid-column: 1 / -1;
} /* Span full width */
.chart-wrapper {
  position: relative;
  height: 400px; /* Adjust as needed */
  margin-top: 15px;
}
#temperatureChart {
  width: 100%;
  height: 100%;
}
.chart-controls {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 0.9em;
}
.chart-controls select,
.chart-controls button {
  padding: 6px 10px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--panel-bg-color);
}

/* Log Panel */
.log-panel {
  grid-column: 1 / -1;
} /* Span full width */
.log-output {
  height: 150px;
  overflow-y: auto;
  border: 1px solid var(--bg-color);
  padding: 10px;
  font-size: 0.85em;
  background-color: #fdfdfd;
  border-radius: 4px;
}
.log-output div {
  padding: 3px 0;
  border-bottom: 1px dotted #eee;
  word-break: break-all;
}
.log-output div:last-child {
  border-bottom: none;
}
.log-output .log-info {
  color: var(--text-color);
}
.log-output .log-error {
  color: var(--error-color);
  font-weight: 500;
}
.log-output .log-cmd_sent {
  color: var(--primary-color);
  font-style: italic;
}
.log-output .log-mcu_unknown {
  color: #777;
}

/* Export Panel */
.export-panel button {
  background-color: var(--success-color);
  margin-right: 10px;
}
.export-panel button:hover {
  background-color: #27ae60;
}

.dashboard-footer {
  background-color: var(--secondary-color);
  color: var(--light-text-color);
  text-align: center;
  padding: 15px;
  font-size: 0.85em;
  opacity: 0.9;
  margin-top: auto; /* Pushes footer to bottom if content is short */
}

/* Responsive Adjustments */
@media (max-width: 768px) {
  .dashboard-main {
    grid-template-columns: 1fr; /* Stack panels on smaller screens */
  }
  .chart-panel,
  .log-panel {
    grid-column: auto; /* Reset span */
  }
  .control-group input[type="number"] {
    width: auto; /* Allow natural width */
    flex-grow: 1;
  }
  .control-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }
  .control-group label {
    flex-basis: 100%;
  }
}

@ static\js\main.js
// static/js/main.js
const socket = io(); // Connect to the Socket.IO server

// DOM Elements
const mcuTimeEl = document.getElementById("mcuTime");
const currentTempEl = document.getElementById("currentTemp");
const setTempEl = document.getElementById("setTemp");
const currentModeEl = document.getElementById("currentMode");
const currentStateEl = document.getElementById("currentState");
const stateAnimationEl = document.getElementById("stateAnimation");
const readIntervalEl = document.getElementById("readInterval");
const lastEqTimeEl = document.getElementById("lastEqTime");

const targetTempInput = document.getElementById("targetTempInput");
const readIntervalInput = document.getElementById("readIntervalInput");
const manualControlsDiv = document.getElementById("manualControls");
const btnModeAuto = document.getElementById("btnModeAuto");
const btnModeManual = document.getElementById("btnModeManual");

const mcuLogOutputEl = document.getElementById("mcuLogOutput");
const chartTimeRangeSelect = document.getElementById("chartTimeRange");

document.getElementById("currentYear").textContent = new Date().getFullYear();

// Chart.js Setup
let temperatureChart;
const chartDataPoints = {
  currentTemp: [],
  setTemp: [],
};
const MAX_LIVE_DATAPOINTS_DEFAULT = 360; // For 1 hour at 10s interval (approx)
let maxLiveDatapoints = MAX_LIVE_DATAPOINTS_DEFAULT;

function initializeChart() {
  const ctx = document.getElementById("temperatureChart").getContext("2d");
  temperatureChart = new Chart(ctx, {
    type: "line",
    data: {
      datasets: [
        {
          label: "Current Temp (Â°C)",
          borderColor: "rgba(230, 126, 34, 1)", // Orange
          backgroundColor: "rgba(230, 126, 34, 0.1)",
          data: chartDataPoints.currentTemp,
          tension: 0.2,
          fill: true,
          pointRadius: 1,
          borderWidth: 2,
        },
        {
          label: "Set Temp (Â°C)",
          borderColor: "rgba(52, 152, 219, 1)", // Blue
          backgroundColor: "rgba(52, 152, 219, 0.1)",
          data: chartDataPoints.setTemp,
          stepped: true,
          fill: false,
          pointRadius: 0,
          borderWidth: 2,
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          type: "time",
          adapters: {
            date: { locale: "en-US" }, // if using luxon
          },
          time: {
            unit: "minute", // Default, will be updated
            tooltipFormat: "MMM d, yyyy, h:mm:ss a",
            displayFormats: {
              millisecond: "h:mm:ss.SSS a",
              second: "h:mm:ss a",
              minute: "h:mm a",
              hour: "h a",
              day: "MMM d",
              week: "MMM d, yyyy",
              month: "MMM yyyy",
            },
          },
          title: { display: true, text: "Time" },
        },
        y: {
          title: { display: true, text: "Temperature (Â°C)" },
          beginAtZero: false, // Or true if temps are always positive
          suggestedMin: 5,
          suggestedMax: 40,
        },
      },
      plugins: {
        legend: { position: "top" },
        tooltip: { mode: "index", intersect: false },
      },
      animation: { duration: 300 }, // Smoother updates
    },
  });
  loadHistoricalData(); // Load initial data
}

// --- SocketIO Event Handlers ---
socket.on("connect", () => {
  addLogMessage("Connected to FermaSense server.", "info");
});

socket.on("disconnect", () => {
  addLogMessage("Disconnected from FermaSense server.", "error");
});

socket.on("new_data", (data) => {
  // console.log('New data:', data);
  mcuTimeEl.textContent = parseFloat(data.mcu_time_s).toFixed(2);
  currentTempEl.textContent = `${parseFloat(data.current_temp).toFixed(1)} Â°C`;
  setTempEl.textContent = `${parseFloat(data.set_temp).toFixed(1)} Â°C`;
  currentModeEl.textContent = data.mode;
  currentStateEl.textContent = data.state;
  updateStateAnimation(data.state);

  const timestamp = new Date(data.server_time_iso).getTime(); // Use server time for chart consistency

  if (temperatureChart) {
    addDataToChart(timestamp, data.current_temp, data.set_temp);
    pruneChartData();
    temperatureChart.update("none"); // 'none' for no animation on frequent live updates
  }
});

socket.on("initial_status", (status) => {
  // console.log('Initial status:', status);
  mcuTimeEl.textContent = parseFloat(status.mcu_time_s).toFixed(2);
  currentTempEl.textContent = `${parseFloat(status.current_temp).toFixed(
    1
  )} Â°C`;
  setTempEl.textContent = `${parseFloat(status.set_temp).toFixed(1)} Â°C`;
  targetTempInput.value = parseFloat(status.set_temp).toFixed(1);
  currentModeEl.textContent = status.mode;
  currentStateEl.textContent = status.state;
  readIntervalEl.textContent = `${status.frequency_ms} ms`;
  readIntervalInput.value = status.frequency_ms;
  updateUIMode(status.mode);
  updateStateAnimation(status.state);
});

socket.on("equalization_update", (data) => {
  // console.log('Equalization:', data);
  lastEqTimeEl.textContent = `To ${parseFloat(data.target_temp).toFixed(
    1
  )}Â°C in ${parseFloat(data.duration_s).toFixed(1)}s (${new Date(
    data.server_time_iso
  ).toLocaleTimeString()})`;
});

socket.on("mcu_log", (log) => {
  // console.log('MCU Log:', log);
  addLogMessage(log.message, log.type);
});

// --- UI Update Functions ---
function updateStateAnimation(state) {
  const stateClass = `state-${state.toLowerCase()}`;
  stateAnimationEl.className = "animation-icon"; // Reset
  stateAnimationEl.classList.add(stateClass);

  if (state === "HEATING") stateAnimationEl.textContent = "ð¥";
  else if (state === "COOLING") stateAnimationEl.textContent = "âï¸";
  else stateAnimationEl.textContent = "ð¤"; // IDLE
}

function updateUIMode(mode) {
  currentModeEl.textContent = mode;
  if (mode === "MANUAL") {
    manualControlsDiv.style.display = "block";
    btnModeManual.classList.add("active");
    btnModeAuto.classList.remove("active");
  } else {
    // AUTO
    manualControlsDiv.style.display = "none";
    btnModeAuto.classList.add("active");
    btnModeManual.classList.remove("active");
  }
}

function addLogMessage(message, type = "info") {
  const logEntry = document.createElement("div");
  logEntry.classList.add(`log-${type.toLowerCase().split("_")[0]}`); // Use base type e.g. 'info', 'error', 'cmd'
  logEntry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")}`; // Sanitize basic HTML
  mcuLogOutputEl.appendChild(logEntry);
  mcuLogOutputEl.scrollTop = mcuLogOutputEl.scrollHeight; // Auto-scroll
}

// --- Chart Functions ---
function addDataToChart(timestamp, currentTemp, setTemp) {
  chartDataPoints.currentTemp.push({
    x: timestamp,
    y: parseFloat(currentTemp),
  });
  chartDataPoints.setTemp.push({ x: timestamp, y: parseFloat(setTemp) });
}

function pruneChartData() {
  const range = chartTimeRangeSelect.value;
  if (range.startsWith("live_")) {
    // Only prune for live views
    while (chartDataPoints.currentTemp.length > maxLiveDatapoints) {
      chartDataPoints.currentTemp.shift();
    }
    while (chartDataPoints.setTemp.length > maxLiveDatapoints) {
      chartDataPoints.setTemp.shift();
    }
  }
}

function updateChartDisplayRange() {
  if (!temperatureChart) return;
  const range = chartTimeRangeSelect.value;
  const now = new Date().getTime();
  let minTime,
    unit = "minute";

  temperatureChart.data.datasets[0].data = []; // Clear existing points before loading/filtering
  temperatureChart.data.datasets[1].data = [];
  chartDataPoints.currentTemp = []; // Also clear our master list for live data
  chartDataPoints.setTemp = [];

  if (range.startsWith("live_")) {
    const hours = parseInt(range.split("_")[1].replace("h", ""));
    minTime = now - hours * 60 * 60 * 1000;
    maxLiveDatapoints =
      hours * 60 * (60 / (readIntervalInput.value / 1000 || 5)); // Estimate based on interval
    if (hours <= 1) unit = "minute";
    else if (hours <= 12) unit = "hour";
    else unit = "day";
    loadHistoricalData(minTime, now); // Reload data for this live window
  } else {
    maxLiveDatapoints = Infinity; // Don't prune historical views
    switch (range) {
      case "day":
        minTime = new Date().setHours(0, 0, 0, 0);
        unit = "hour";
        break;
      case "3days":
        minTime = now - 3 * 24 * 60 * 60 * 1000;
        unit = "day";
        break;
      case "week":
        minTime = now - 7 * 24 * 60 * 60 * 1000;
        unit = "day";
        break;
      case "all":
      default:
        minTime = null;
        unit = "day";
        break; // Load all
    }
    loadHistoricalData(minTime, now); // Load historical data up to now for these ranges
  }
  temperatureChart.options.scales.x.min = minTime;
  temperatureChart.options.scales.x.max = now + 5 * 60 * 1000; // Add a bit of future padding for live
  temperatureChart.options.scales.x.time.unit = unit;
  temperatureChart.update();
}

async function loadHistoricalData(startTime = null, endTime = null) {
  try {
    addLogMessage("Loading chart data...", "info");
    const response = await fetch("/get_historical_data");
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();

    // Clear current points before loading historical
    chartDataPoints.currentTemp = [];
    chartDataPoints.setTemp = [];

    data.forEach((point) => {
      const pointTime = point.x; // Already in ms from server
      if (
        (!startTime || pointTime >= startTime) &&
        (!endTime || pointTime <= endTime)
      ) {
        chartDataPoints.currentTemp.push({
          x: pointTime,
          y: point.current_temp,
        });
        chartDataPoints.setTemp.push({ x: pointTime, y: point.set_temp });
      }
    });

    if (temperatureChart) {
      // Sort data just in case it's not perfectly ordered from CSV
      chartDataPoints.currentTemp.sort((a, b) => a.x - b.x);
      chartDataPoints.setTemp.sort((a, b) => a.x - b.x);

      temperatureChart.data.datasets[0].data = chartDataPoints.currentTemp;
      temperatureChart.data.datasets[1].data = chartDataPoints.setTemp;
      temperatureChart.update();
      addLogMessage(
        `Chart data loaded: ${chartDataPoints.currentTemp.length} points.`,
        "info"
      );
    }
  } catch (error) {
    console.error("Could not load historical data:", error);
    addLogMessage(`Error loading chart data: ${error}`, "error");
  }
}

// --- Command Functions ---
function sendCommandToMCU(command) {
  fetch("/send_command_to_mcu", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: `command=${encodeURIComponent(command)}`,
  })
    .then((response) => response.json())
    .then((data) => {
      // Log is already handled by server emitting 'mcu_log' after sending.
      // console.log('Command sent response:', data);
      if (command === "MODE_AUTO") updateUIMode("AUTO");
      if (command === "MODE_MANUAL") updateUIMode("MANUAL");
    })
    .catch((error) => {
      console.error("Error sending command:", error);
      addLogMessage(`WEB UI Error sending command: ${error}`, "error");
    });
}

function setTargetTemperature() {
  const temp = parseFloat(targetTempInput.value);
  if (
    !isNaN(temp) &&
    temp >= parseFloat(targetTempInput.min) &&
    temp <= parseFloat(targetTempInput.max)
  ) {
    sendCommandToMCU(`SET_TEMP=${temp.toFixed(1)}`);
  } else {
    addLogMessage(
      `Invalid target temperature: ${targetTempInput.value}. Must be between ${targetTempInput.min}-${targetTempInput.max}.`,
      "error"
    );
  }
}

function setReadInterval() {
  const interval = parseInt(readIntervalInput.value);
  if (
    !isNaN(interval) &&
    interval >= parseInt(readIntervalInput.min) &&
    interval <= parseInt(readIntervalInput.max)
  ) {
    sendCommandToMCU(`SET_FREQ=${interval}`);
    // Update readIntervalEl immediately for responsiveness, MCU will confirm
    readIntervalEl.textContent = `${interval} ms`;
  } else {
    addLogMessage(
      `Invalid read interval: ${readIntervalInput.value}. Must be between ${readIntervalInput.min}-${readIntervalInput.max}.`,
      "error"
    );
  }
}

function downloadLog(logType) {
  window.location.href = `/download_log/${logType}`;
}

// --- Initialization ---
window.onload = () => {
  initializeChart();
  // Set initial range (will trigger loadHistoricalData)
  updateChartDisplayRange();
  // Request initial status again in case of reconnect
  setTimeout(() => sendCommandToMCU("GET_STATUS"), 1000);
};
